import datetime as dt

# Нарушения требований документа "Практикум. Требования к коду студентов":
# 1. практически везде отсутствуют комментарии к методам:
#    хотелось бы видеть краткие описания, поясняющие суть реализуемого функционала в классах и методах
# 2. отсутствуют пустые строки, логически разделяющие длинные куски кода


class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        # 1. self.date = (...) - использование скобок здесь излишне:
        #    они не привносят никакой функциональности и создают эффект нагромождения
        # 2. способ переноса компонентов конструкции if-else крайне затрудняет её восприятие:
        #    как минимум "if not date" должны располагаться внутри одной строки
        # 3. т.к. парсинг даты происходит тут, следовало бы обработать ситуацию, когда в качестве даты передана неверная информация
        #    Здесь был бы уместен блок try except
        self.date = (
            dt.datetime.now().date() if
            not
            date else dt.datetime.strptime(date, '%d.%m.%Y').date())
        self.comment = comment


class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    def add_record(self, record):
        self.records.append(record)

    def get_today_stats(self):
        today_stats = 0
        # именуя переменную Record с заглавной буквы, вы не только нарушаете соглашения PEP8 о наименовании переменных,
        # но и теряете возможность обращаться к выше объявленному классу Record в данной области кода
        for Record in self.records:
            # 1. вычислять dt.datetime.now().date() на каждой итерации цикла избыточно, т.к. дата предполагается одна и та же.
            #    Лучше посчитать дату до начала цикла и записать её в переменную, к которой обращаться внутри цикла.
            # 2. кроме того, хоть это и крайне редкий случай, но в ходе выполнения цикла может настать завтра и каких-то данных можно не досчитаться.
            #    Это серьёзный логический просчёт, особенно с учётом кода в get_week_stats(), который говорит о том, что вы в курсе опции с выносом вычисления даты в переменную над циклом
            if Record.date == dt.datetime.now().date():
                # эту конструкцию можно было бы записать короче today_stats += Record.amount
                today_stats = today_stats + Record.amount
        return today_stats

    def get_week_stats(self):
        week_stats = 0
        today = dt.datetime.now().date()
        for record in self.records:
            # 1. избыточное использование скобок в условном выражении "if (...):":
            #    скобки были бы оправданы при управлении приоритетами операций, например "if (a or b) and x"
            # 2. это условное выражение можно было бы записать так: 0 <= (today - record.date).days < 7
            #    это легче воспринимается и не нужно было бы дважды вычислять (today - record.date).days
            if (
                (today - record.date).days < 7 and
                (today - record.date).days >= 0
            ):
                week_stats += record.amount
        return week_stats


class CaloriesCalculator(Calculator):
    # неверное оформление поясняющего комментария к методу. Необходимо использовать Docstrings-формат
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        x = self.limit - self.get_today_stats()
        if x > 0:
            # нарушение требований документа "Практикум. Требования к коду студентов": применение \ для переноса
            return f'Сегодня можно съесть что-нибудь' \
                   f' ещё, но с общей калорийностью не более {x} кКал'
        # избыточное использование else
        else:
            # избыточное использование скобок
            return('Хватит есть!')


class CashCalculator(Calculator):
    # избыточная конвертация данных
    # достаточно было бы написать USD_RATE = 60.0
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.

    # неверное наименование параметров метода USD_RATE, EURO_RATE.
    # Следует записать их в нижнем регистре: usd_rate, euro_rate
    def get_today_cash_remained(self, currency,
                                USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        #    следует быть последовательным в использовании переменных, закрепляя за ними некую логику
        #    Если вы решили, что currency_type - это текстовое обозначение денежной единицы,
        #    то не следовало в неё записывать значение currency, а уж тем более использовать её далее в сравнениях типа currency_type == 'eur'
        #    С этой точки зрения и наименование currency_type для этой переменной не особо подходит. Понятнее было бы currency_label
        #    По итогу код выглядел бы:
        #    currency_label = ''
        #    if currency == 'usd':
        #        currency_label = 'USD'
        #        ...
        #    elif currency == 'eur':
        #        currency_label = 'Euro'
        #        ...
        currency_type = currency
        cash_remained = self.limit - self.get_today_stats()
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            # вычисление cash_remained в случаях с usd и eur понятно - оставшуюся сумму делим на курс, получаем сумму в валюте
            # почему здесь cash_remained стал коэффициентом пересчёта рубля в рубли? И ниже по коду выходит, что у нас всегда на остатке 1 рубль?
            cash_remained == 1.00
            currency_type = 'руб'
        # тут не хватает блока else, который бы обработал ситуацию, когда currency не usd, не eur и не rub
        if cash_remained > 0:  # перед этой строкой следовало бы вставить пустую строку, чтобы визуально сходу стало понятно, что здесь начало нового блока if, а не продолжение предыдущего
            # 1. избыточное использование скобок return (...)
            # 2. ничем не оправданный перенос f'{currency_type}' на следующую строку
            # 3. нарушение требований документа "Практикум. Требования к коду студентов":
            #    В f-строках применяется только подстановка переменных и нет логических или арифметических операций, вызовов функций и подобной динамики.
            return (
                f'На сегодня осталось {round(cash_remained, 2)} '
                f'{currency_type}'
            )
        # вместо elif корректнее использовать if, поскольку подразумеваемое else никогда не произойдёт из-за return
        elif cash_remained == 0:
            return 'Денег нет, держись'
        # 1. аналогично лучше использовать if вместо elif
        # 2. тут можно было бы вообще никаких условий не писать, т.к. кроме cash_remained < 0 других вариантов больше и нет
        elif cash_remained < 0:
            # 1. нарушение требований документа "Практикум. Требования к коду студентов": применение \ для переноса
            # 2. если бы вместо format(-cash_remained) было написано format(abs(cash_remained)), код был бы более интуитивно понятен.
            #    Когда читаешь чужой или свой давний код, не всегда фокус внимания захватывает все нюансы.
            #    Конкретизируя код, мы помогаем коллегам и себе в будущем.
            return 'Денег нет, держись:' \
                   ' твой долг - {0:.2f} {1}'.format(-cash_remained,
                                                     currency_type)

    # избыточное объявление метода,
    # поскольку внутри него не добавляется новый функционал и никак не меняется функционал родительского
    def get_week_stats(self):
        super().get_week_stats()
